<section class="com-2-panel col-2-article J-articlePanel"><div class="col-2-article-header"><h1 class="article-title J-articleTitle"><span>Android启动过程分析(图+文)</span></h1><div class="article-infos-wrap"><div class="article-infos"><span class="article-info"><time datetime="2018-10-22 11:29:56" title="2018-10-22 11:29:56"> 2018-10-22<span class="com-v-box">2018-10-22 11:29:56</span></time></span><span class="article-info">阅读 <!-- -->1.2K</span>0</div><div class="article-infos-extra"></div></div></div><div class="com-markdown-collpase"><div class="com-markdown-collpase-main"><div class="rno-markdown J-articleContent"><blockquote><p>本文以图文并茂的形式简单介绍一个APP从启动到主页面显示经历了哪些流程，以及实现的原理。不介绍具体源码，仅仅构建一个大体框架</p></blockquote><h3 id="%E4%B8%80%E3%80%81%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0" name="%E4%B8%80%E3%80%81%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0">一、流程概述</h3><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-3504348/7q1aalyco4.jpeg?imageView2/2/w/1620" class="" style="cursor: zoom-in;"></span></div></figure><h5 id="%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%9A" name="%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%9A">启动流程：</h5><p>①点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；</p><p>②system_server进程接收到请求后，向zygote进程发送创建进程的请求；</p><p>③Zygote进程fork出新的子进程，即App进程；</p><p>④App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；</p><p>⑤system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；</p><p>⑥App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；</p><p>⑦主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。</p><p>⑧到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。</p><p>上面的一些列步骤简单介绍了一个APP启动到主页面显示的过程，可能这些流程中的一些术语看的有些懵，什么是Launcher，什么是zygote，什么是applicationThread.....</p><p>下面我们一一介绍。</p><h3 id="%E4%BA%8C%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80" name="%E4%BA%8C%E3%80%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">二、理论基础</h3><h4 id="1.zygote" name="1.zygote">1.zygote</h4><p>zygote意为“受精卵“。Android是基于Linux系统的，而在Linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote进程也不例外。</p><p>在Android系统里面，zygote是一个进程的名字。Android是基于Linux  System的，当你的手机开机的时候，Linux的内核加载完成之后就会启动一个叫“init“的进程。在Linux  System里面，所有的进程都是由init进程fork出来的，我们的zygote进程也不例外。</p><p>我们都知道，每一个App其实都是</p><p>● 一个单独的dalvik虚拟机
● 一个单独的进程</p><p>所以当系统里面的第一个zygote进程运行之后，在这之后再开启App，就相当于开启一个新的进程。而为了实现资源共用和更快的启动速度，Android系统开启新进程的方式，是通过fork第一个zygote进程实现的。所以说，除了第一个zygote进程，其他应用所在的进程都是zygote的子进程，这下你明白为什么这个进程叫“受精卵”了吧？因为就像是一个受精卵一样，它能快速的分裂，并且产生遗传物质一样的细胞！</p><h4 id="2.system_server" name="2.system_server">2.system_server</h4><p>SystemServer也是一个进程，而且是由zygote进程fork出来的。</p><p>知道了SystemServer的本质，我们对它就不算太陌生了，这个进程是Android Framework里面两大非常重要的进程之一——另外一个进程就是上面的zygote进程。</p><p>为什么说SystemServer非常重要呢？因为系统里面重要的服务都是在这个进程里面开启的，比如
ActivityManagerService、PackageManagerService、WindowManagerService等等。</p><h4 id="3.ActivityManagerService" name="3.ActivityManagerService">3.ActivityManagerService</h4><p>ActivityManagerService，简称AMS，服务端对象，负责系统中所有Activity的生命周期。</p><p>ActivityManagerService进行初始化的时机很明确，就是在SystemServer进程开启的时候，就会初始化ActivityManagerService。</p><h6 id="%E4%B8%8B%E9%9D%A2%E4%BB%8B%E7%BB%8D%E4%B8%8BAndroid%E7%B3%BB%E7%BB%9F%E9%87%8C%E9%9D%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82" name="%E4%B8%8B%E9%9D%A2%E4%BB%8B%E7%BB%8D%E4%B8%8BAndroid%E7%B3%BB%E7%BB%9F%E9%87%8C%E9%9D%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82">下面介绍下Android系统里面的服务器和客户端的概念。</h6><p>其实服务器客户端的概念不仅仅存在于Web开发中，在Android的框架设计中，使用的也是这一种模式。服务器端指的就是所有App共用的系统服务，比如我们这里提到的ActivityManagerService，和前面提到的PackageManagerService、WindowManagerService等等，这些基础的系统服务是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你想打开一个App，那么我们知道了包名和MainActivity类名之后就可以打开</p><pre class="prism-token token  language-javascript">Intent intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span>Intent<span class="token punctuation">.</span>ACTION_MAIN<span class="token punctuation">)</span><span class="token punctuation">;</span>  
intent<span class="token punctuation">.</span><span class="token function">addCategory</span><span class="token punctuation">(</span>Intent<span class="token punctuation">.</span>CATEGORY_LAUNCHER<span class="token punctuation">)</span><span class="token punctuation">;</span>              ComponentName cn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComponentName</span><span class="token punctuation">(</span>packageName<span class="token punctuation">,</span> className<span class="token punctuation">)</span><span class="token punctuation">;</span>              
intent<span class="token punctuation">.</span><span class="token function">setComponent</span><span class="token punctuation">(</span>cn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">startActivity</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span></pre><p>注：可以左右滑动</p><p>但是，我们的App通过调用startActivity()并不能直接打开另外一个App，这个方法会通过一系列的调用，最后还是告诉AMS说：“我要打开这个App，我知道他的住址和名字，你帮我打开吧！”所以是AMS来通知zygote进程来fork一个新进程，来开启我们的目标App的。这就像是浏览器想要打开一个超链接一样，浏览器把网页地址发送给服务器，然后还是服务器把需要的资源文件发送给客户端的。</p><p>知道了Android Framework的客户端服务器架构之后，我们还需要了解一件事情，那就是我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？</p><p>App与AMS通过Binder进行IPC通信，AMS(SystemServer进程)与zygote通过Socket进行IPC通信。后面具体介绍。</p><p>那么AMS有什么用呢？在前面我们知道了，如果想打开一个App的话，需要AMS去通知zygote进程，除此之外，其实所有的Activity的开启、暂停、关闭都需要AMS来控制，所以我们说，AMS负责系统中所有Activity的生命周期。</p><p>在Android系统中，任何一个Activity的启动都是由AMS和应用程序进程（主要是ActivityThread）相互配合来完成的。AMS服务统一调度系统中所有进程的Activity启动，而每个Activity的启动过程则由其所属的进程具体来完成。</p><h4 id="4.Launcher" name="4.Launcher">4.Launcher</h4><p>当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。但是，你有没有思考过Launcher到底是一个什么东西？</p><p>Launcher本质上也是一个应用程序，和我们的App一样，也是继承自Activity</p><p>packages/apps/Launcher2/src/com/android/launcher2/Launcher.java</p><pre class="prism-token token  language-javascript"><span class="token keyword">public</span> final <span class="token keyword">class</span> <span class="token class-name">Launcher</span> <span class="token keyword">extends</span> <span class="token class-name">Activity</span> <span class="token keyword">implements</span> <span class="token class-name">View<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">,</span> OnLongClickListener<span class="token punctuation">,</span> LauncherModel<span class="token punctuation">.</span>Callbacks<span class="token punctuation">,</span>                   
    View<span class="token punctuation">.</span>OnTouchListener <span class="token punctuation">{</span>        <span class="token punctuation">}</span></pre><p>Launcher实现了点击、长按等回调接口，来接收用户的输入。既然是普通的App，那么我们的开发经验在这里就仍然适用，比如，我们点击图标的时候，是怎么开启的应用呢？捕捉图标点击事件，然后startActivity()发送对应的Intent请求呗！是的，Launcher也是这么做的，就是这么easy！</p><h4 id="5.Instrumentation%E5%92%8CActivityThread" name="5.Instrumentation%E5%92%8CActivityThread">5.Instrumentation和ActivityThread</h4><p>每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。
Instrumentation这个类里面的方法大多数和Application和Activity有关，这个类就是完成对Application和Activity初始化和生命周期的工具类。Instrumentation这个类很重要，对Activity生命周期方法的调用根本就离不开他，他可以说是一个大管家。</p><p>ActivityThread，就是UI线程。App和AMS是通过Binder传递信息的，那么ActivityThread就是专门与AMS的外交工作的。</p><h4 id="6.ApplicationThread" name="6.ApplicationThread">6.ApplicationThread</h4><p>前面我们已经知道了App的启动以及Activity的显示都需要AMS的控制，那么我们便需要和服务端的沟通，而这个沟通是双向的。</p><p>客户端--&gt;服务端</p><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-3504348/c8rumi289v.png?imageView2/2/w/1620" class="" style="cursor: zoom-in;"></span></div></figure><p>而且由于继承了同样的公共接口类，ActivityManagerProxy提供了与ActivityManagerService一样的函数原型，使用户感觉不出Server是运行在本地还是远端，从而可以更加方便的调用这些重要的系统服务。</p><p>服务端--&gt;客户端</p><p>还是通过Binder通信，不过是换了另外一对，换成了ApplicationThread和ApplicationThreadProxy。</p><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-3504348/yw2k1442g0.png?imageView2/2/w/1620" class="" style="cursor: zoom-in;"></span></div></figure><p>
他们也都实现了相同的接口IApplicationThread</p><pre class="prism-token token  language-javascript">  <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationThread</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationThreadNative</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">public</span> abstract <span class="token keyword">class</span> <span class="token class-name">ApplicationThreadNative</span> <span class="token keyword">extends</span> <span class="token class-name">Binder</span> <span class="token keyword">implements</span> <span class="token class-name">IApplicationThread</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  
  <span class="token keyword">class</span> <span class="token class-name">ApplicationThreadProxy</span> <span class="token keyword">implements</span> <span class="token class-name">IApplicationThread</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></pre><p>好了，前面罗里吧嗦的一大堆，介绍了一堆名词，可能不太清楚，没关系，下面结合流程图介绍。</p><h3 id="%E4%B8%89%E3%80%81%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B" name="%E4%B8%89%E3%80%81%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">三、启动流程</h3><h4 id="1.%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B" name="1.%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B">1.创建进程</h4><p>①先从Launcher的startActivity()方法，通过Binder通信，调用ActivityManagerService的startActivity方法。</p><p>②一系列折腾，最后调用startProcessLocked()方法来创建新的进程。</p><p>③该方法会通过前面讲到的socket通道传递参数给Zygote进程。Zygote孵化自身。调用ZygoteInit.main()方法来实例化ActivityThread对象并最终返回新进程的pid。</p><p>④调用ActivityThread.main()方法，ActivityThread随后依次调用Looper.prepareLoop()和Looper.loop()来开启消息循环。</p><p>方法调用流程图如下:</p><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-3504348/9gp8xfcf20.jpeg?imageView2/2/w/1620" class="" style="cursor: zoom-in;"></span></div></figure><p>
更直白的流程解释：
</p><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-3504348/443s2g8ko8.jpeg?imageView2/2/w/1620" class="" style="cursor: zoom-in;"></span></div></figure><p>
①App发起进程：当从桌面启动应用，则发起进程便是Launcher所在进程；当从某App内启动远程进程，则发送进程便是该App所在进程。发起进程先通过binder发送消息给system_server进程；</p><p>②system_server进程：调用Process.start()方法，通过socket向zygote进程发送创建新进程的请求；</p><p>③zygote进程：在执行ZygoteInit.main()后便进入runSelectLoop()循环体内，当有客户端连接时便会执行ZygoteConnection.runOnce()方法，再经过层层调用后fork出新的应用进程；</p><p>④新进程：执行handleChildProc方法，最后调用ActivityThread.main()方法。</p><h4 id="2.%E7%BB%91%E5%AE%9AApplication" name="2.%E7%BB%91%E5%AE%9AApplication">2.绑定Application</h4><p>上面创建进程后，执行ActivityThread.main()方法，随后调用attach()方法。</p><p>将进程和指定的Application绑定起来。这个是通过上节的ActivityThread对象中调用bindApplication()方法完成的。该方法发送一个BIND_APPLICATION的消息到<a data-text-link="8_1356506" data-from="10680" href="https://cloud.tencent.com/product/cmq?from=10680" target="_blank">消息队列</a>中,  最终通过handleBindApplication()方法处理该消息.  然后调用makeApplication()方法来加载App的classes到内存中。</p><p>方法调用流程图如下：</p><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-3504348/1y9su3gqig.jpeg?imageView2/2/w/1620" class="" style="cursor: zoom-in;"></span></div></figure><p>
更直白的流程解释：
</p><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-3504348/485aicfhv8.jpeg?imageView2/2/w/1620" class="" style="cursor: zoom-in;"></span></div></figure><p>
（如果看不懂AMS,ATP等名词，后面有解释）</p><h4 id="3.%E6%98%BE%E7%A4%BAActivity%E7%95%8C%E9%9D%A2" name="3.%E6%98%BE%E7%A4%BAActivity%E7%95%8C%E9%9D%A2">3.显示Activity界面</h4><p>经过前两个步骤之后, 系统已经拥有了该application的进程。 后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了。</p><p>实际调用方法是realStartActivity(),   它会调用application线程对象中的scheduleLaunchActivity()发送一个LAUNCH_ACTIVITY消息到消息队列中,  通过 handleLaunchActivity()来处理该消息。在  handleLaunchActivity()通过performLaunchActiivty()方法回调Activity的onCreate()方法和onStart()方法，然后通过handleResumeActivity()方法，回调Activity的onResume()方法，最终显示Activity界面。
</p><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-3504348/fdqw4yp18z.jpeg?imageView2/2/w/1620" class="" style="cursor: zoom-in;"></span></div></figure><p>更直白的流程解释：</p><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-3504348/ybppd4tqns.png?imageView2/2/w/1620" class="" style="cursor: zoom-in;"></span></div></figure><h3 id="%E5%9B%9B%E3%80%81Binder%E9%80%9A%E4%BF%A1" name="%E5%9B%9B%E3%80%81Binder%E9%80%9A%E4%BF%A1">四、Binder通信</h3><figure><div class="image-block"><span><img src="https://ask.qcloudimg.com/http-save/yehe-3504348/vrh1oueni9.jpeg?imageView2/2/w/1620" class="" style="cursor: zoom-in;"></span></div></figure><h5 id="%E7%AE%80%E7%A7%B0:" name="%E7%AE%80%E7%A7%B0:">简称:</h5><p>ATP: ApplicationThreadProxy</p><p>AT: ApplicationThread</p><p>AMP: ActivityManagerProxy</p><p>AMS: ActivityManagerService</p><h5 id="%E5%9B%BE%E8%A7%A3:" name="%E5%9B%BE%E8%A7%A3:">图解:</h5><p>①system_server进程中调用startProcessLocked方法,该方法最终通过socket方式,将需要创建新进程的消息告知Zygote进程,并阻塞等待Socket返回新创建进程的pid;</p><p>②Zygote进程接收到system_server发送过来的消息, 则通过fork的方法，将zygote自身进程复制生成新的进程，并将ActivityThread相关的资源加载到新进程app process,这个进程可能是用于承载activity等组件;</p><p>③  在新进程app process向servicemanager查询system_server进程中binder服务端AMS,  获取相对应的Client端,也就是AMP. 有了这一对binder c/s对, 那么app  process便可以通过binder向跨进程system_server发送请求,即attachApplication()</p><p>④system_server进程接收到相应binder操作后,经过多次调用,利用ATP向app process发送binder请求, 即bindApplication.
system_server拥有ATP/AMS, 每一个新创建的进程都会有一个相应的AT/AMP,从而可以跨进程 进行相互通信. 这便是进程创建过程的完整生态链。</p><p>以上大概介绍了一个APP从启动到主页面显示经历的流程，主要从宏观角度介绍了其过程，具体可结合源码理解。</p></div><div class="col-2-article-source"><p>本文分享自微信公众号 - <!-- -->Android历练记（gh_db8538619cdd）<!-- -->，作者：SYfarming</p><p>原文出处及转载信息见文内详细说明，如有侵权，请联系 <!-- -->yunjia_community@tencent.com<!-- --> 删除。</p><p>原始发表时间：<!-- -->2017-07-24</p><p>本文参与<a href="/developer/support-plan" class="com-link">腾讯云自媒体分享计划</a>，欢迎正在阅读的你也加入，一起分享。</p></div></div><div class="com-markdown-collpase-toggle"><a href="javascript:;" class="toggle-link">展开阅读全文</a></div></div><div class="col-2-article-tags"><nav class="col-tags"><a href="/developer/tag/125?entry=article" class="col-tag">其他</a></nav><div class="extra-part"><div class="com-operations"><a href="javascript:;" class="com-opt-link link-warn"><i class="com-i-warn"></i>举报</a></div></div></div><div class="col-2-article-opts"><button type="button" class="c-btn"><span class="text"><i class="opt-icon like"></i>点赞 5</span></button><button type="button" class="c-btn c-btn-weak"><span class="text"><i class="opt-icon share"></i>分享</span></button></div><section class="group-comments"><div class="com-comment-single-edit theme2"><header class="edit-hd"><h3 class="edit-title"><i class="edit-icon"></i>我来说两句</h3><div class="edit-count"><span class="edit-count-num">0</span> 条评论</div></header><div class="edit-body"><div class="edit-textarea"></div><div class="edit-tip"><a href="javascript:;">登录</a> 后参与评论</div></div></div><section class="com-comment-popup"><div class="popup-bd"><div></div></div></section></section></section>
